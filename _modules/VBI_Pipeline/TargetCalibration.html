
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>VBI_Pipeline.TargetCalibration &#8212; VBI_Pipeline v0.8.2</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700" type="text/css" />
    <link rel="stylesheet" href="../../_static/dkist.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../../_static/favico.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="col-md-3 navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://nso.edu"><img src="../../_static/img/NSOlogo.gif">
        </a>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav hidden">
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">VBI Pipeline Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthrough.html">Data Reduction Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config_file.html">Configuration File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../IPA_access.html">Instrument Partner Testing Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Reference/API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>
          
            <ul class="nav navbar-nav navbar-left">
              <li><a href="http://dkist.nso.edu/">DKIST</a></li>
              <li><a href="http://docs.cadair.com/devdocs">DC Developer Guide</a></li>
              <li><a href="http://docs.cadair.com/datarate">DKIST Data Rate</a></li>
              <li><a href="http://docs.cadair.com/datamodel">DKIST Data Model</a></li>
            </ul>
          
          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">

    <div class="col-md-3"><div id="side-logo" >
            <a href="http://dkist.nso.edu">
                <img src="../../_static/img/DKISTLogo-Medium.jpg">
            </a>
        </div><div id="sidebar" class="bs-sidenav" role="complementary">
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">VBI Pipeline Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthrough.html">Data Reduction Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config_file.html">Configuration File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../IPA_access.html">Instrument Partner Testing Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Reference/API</a></li>
</ul>

            
        </div>
    </div>

    <div class="body col-md-9 content" role="main">
      
  <h1>Source code for VBI_Pipeline.TargetCalibration</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span> <span class="k">as</span> <span class="n">pyfits</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_pdf</span> <span class="kn">import</span> <span class="n">PdfPages</span> <span class="k">as</span> <span class="n">PDF</span>
<span class="kn">import</span> <span class="nn">peakutils</span> <span class="k">as</span> <span class="nn">pku</span>
<span class="kn">import</span> <span class="nn">skimage.transform</span> <span class="k">as</span> <span class="nn">skit</span>
<span class="kn">import</span> <span class="nn">skimage.filters</span> <span class="k">as</span> <span class="nn">skif</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">spnd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">VBI_Pipeline</span> <span class="kn">import</span> <span class="n">Data</span><span class="p">,</span> <span class="n">generic</span><span class="p">,</span> <span class="n">FLUSH</span>
<span class="kn">from</span> <span class="nn">VBI_Pipeline.tag</span> <span class="kn">import</span> <span class="n">tag</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;classic&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.main.html#VBI_Pipeline.TargetCalibration.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">grid_dir</span><span class="p">,</span> <span class="n">outname</span><span class="p">,</span> <span class="n">dark_cal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gain_cal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mf">15.</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
         <span class="n">refidx</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">bimode_choice</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a TargetCalibration (i.e., wcs sub-pixel offsets) given an input linegrid image.</span>

<span class="sd">    Pre-processing by dark and gain Calibration products can be induced by specifying the corresponding FitsData</span>
<span class="sd">    objects. The gain calibration, in particular, is extremely necessary for good analysis.</span>

<span class="sd">    The 4 special parameters exposed here (gauss_sigma, dmax, rho_min_dist, and refidx) vary greatly whether considering</span>
<span class="sd">    Blue or Red camera data. Watch out!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid_dir : str</span>
<span class="sd">        Location of directory containing the linegrid data</span>

<span class="sd">    outname : str</span>
<span class="sd">        The path of the resulting Target Calibration Data.FitsData file</span>

<span class="sd">    dark_cal : Data.FitsData</span>
<span class="sd">        A Dark Calibration object</span>

<span class="sd">    gain_cal : Data.FitsData</span>
<span class="sd">        A Gain Calibration object</span>

<span class="sd">    gauss_sigma : float</span>
<span class="sd">        Width of smoothing kernel used to construct a binary image from the input data. Should be slightly less than</span>
<span class="sd">        the pixel width of the grid lines.</span>

<span class="sd">    dmax : float</span>
<span class="sd">        Any intersections with pixel locations less than dmax apart are considered to be the same intersection.</span>

<span class="sd">    rho_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in rho. This parameter is highly dependent</span>
<span class="sd">        on the pixel scale of the grid lines.</span>

<span class="sd">    refidx : int</span>
<span class="sd">        Index of the reference hdu to use. Index corresponds to the location in both intsects and pos_list</span>

<span class="sd">    rho_smooth : float</span>
<span class="sd">        Sigma of smoothing kernel used to remove noise from the rho rss. Something b/t 5 and 10 is probably good.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the binary thresholding</span>
<span class="sd">        calculation.</span>

<span class="sd">    bimode_choice : list</span>
<span class="sd">        List containing the automatic choice for potential bimodality in the (x, y) dimensions. Choice can be either</span>
<span class="sd">        1 or 2; 1 always corresponds to the mode closest to the global median.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True the code will stop at each hdu (i.e., camera position) and generate some diagnostic plots that show the</span>
<span class="sd">        computed lines and grid intersections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Data.FitsData</span>
<span class="sd">        A Target Calibration.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">pkl_name</span> <span class="o">=</span> <span class="n">load_hough_pickle</span><span class="p">(</span><span class="n">outname</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">intersections</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;grid_proc.fits&#39;</span><span class="p">):</span>
        <span class="n">gridData</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">AlignmentData</span><span class="p">(</span><span class="n">grid_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dark_cal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: doing Dark Correction&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
            <span class="n">generic</span><span class="o">.</span><span class="n">dark_correction</span><span class="p">(</span><span class="n">gridData</span><span class="p">,</span> <span class="n">dark_cal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">FLUSH</span><span class="p">:</span>
                <span class="n">gridData</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">gain_cal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: doing Gain Correction&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
            <span class="n">generic</span><span class="o">.</span><span class="n">gain_correction</span><span class="p">(</span><span class="n">gridData</span><span class="p">,</span> <span class="n">gain_cal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">FLUSH</span><span class="p">:</span>
                <span class="n">gridData</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: averaging data&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">proc_gridData</span> <span class="o">=</span> <span class="n">generic</span><span class="o">.</span><span class="n">average_FitsData</span><span class="p">(</span><span class="n">gridData</span><span class="p">)</span>

        <span class="c1"># skimage likes working on images with values -1 to 1</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">proc_gridData</span><span class="o">.</span><span class="n">data_hdus</span><span class="p">:</span>
            <span class="n">h</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">)])</span>
            <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">procname</span> <span class="o">=</span> <span class="s1">&#39;grid_proc.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_dir</span><span class="p">)</span>
        <span class="n">proc_gridData</span><span class="o">.</span><span class="n">write_out</span><span class="p">(</span><span class="n">procname</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: saved processed linegrid image as </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">procname</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;grid_proc.fits&#39;</span><span class="p">):</span>
        <span class="n">proc_gridData</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;grid_proc.fits&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">intersections</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: finding line intersections&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span> <span class="o">=</span> <span class="n">collect_intersections</span><span class="p">(</span><span class="n">proc_gridData</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span>
                                                        <span class="n">rho_smooth</span><span class="o">=</span><span class="n">rho_smooth</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="n">binary_threshold</span><span class="p">,</span>
                                                        <span class="n">sigclip</span><span class="o">=</span><span class="n">sigclip</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: saving hough pickle to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pkl_name</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pkl_name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: generating target calibration&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
    <span class="n">target_calibration</span> <span class="o">=</span> <span class="n">generate_target_calibration</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">proc_gridData</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="n">output</span><span class="o">=</span><span class="n">outname</span><span class="p">,</span> <span class="n">bimode_choice</span><span class="o">=</span><span class="n">bimode_choice</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target_calibration</span></div>


<div class="viewcode-block" id="load_hough_pickle"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.load_hough_pickle.html#VBI_Pipeline.TargetCalibration.load_hough_pickle">[docs]</a><span class="k">def</span> <span class="nf">load_hough_pickle</span><span class="p">(</span><span class="n">outname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load a previously-computed set of intersections and position list.</span>

<span class="sd">    This can save a huge amount of time by bypassing the hough transform steps if all that&#39;s needed is to, e.g., change</span>
<span class="sd">    the value of dmax.</span>

<span class="sd">    This is a separate function for now (rather than just being in main) because it might have some sanity checks in the</span>
<span class="sd">    future.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    outname : str</span>
<span class="sd">        The path to the final TargetCalibration object. This is used to auto-generate the saved intersection filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lst or None</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2,</span>
<span class="sd">        N) containing the (x,y) corrdinates for the N intersections found in that hdu. If no file is found then None is</span>
<span class="sd">        returned.</span>

<span class="sd">    lst or None</span>
<span class="sd">        A list containing the camera positions (VBI__005) of each corresponding hdu. If no save file was found then None</span>
<span class="sd">        is returned.</span>

<span class="sd">    str</span>
<span class="sd">        The name of the loaded/saved intersection/position file. Data are saved with python&#39;s pickle framework.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pkl_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_houghres.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pkl_name</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: found previous hough pickle at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pkl_name</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pkl_name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">pkl_name</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pkl_name</span></div>


<div class="viewcode-block" id="collect_intersections"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.collect_intersections.html#VBI_Pipeline.TargetCalibration.collect_intersections">[docs]</a><span class="k">def</span> <span class="nf">collect_intersections</span><span class="p">(</span><span class="n">gridData</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                          <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                          <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">hough_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a list grid intersection points for each hdu in the input data.</span>

<span class="sd">    The general algorithm for each hdu is:</span>

<span class="sd">     1. Create a binary image</span>
<span class="sd">     2. Find grid lines using the Hough Transform</span>
<span class="sd">     3. Compute the intersections of all of the discovered lines</span>

<span class="sd">    See associated helper functions for more detailed information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gridData : Data.FitsData</span>
<span class="sd">        Data object containing a linegrid image or series thereof</span>

<span class="sd">    rho_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in rho. This parameter is highly dependent</span>
<span class="sd">        on the pixel scale of the grid lines.</span>

<span class="sd">    gauss_sigma : float</span>
<span class="sd">        Width of smoothing kernel used to construct a binary image from the input data. Should be slightly less than</span>
<span class="sd">        the pixel width of the grid lines.</span>

<span class="sd">    rho_smooth : float</span>
<span class="sd">        Sigma of smoothing kernel used to remove noise from the rho rss. Something b/t 5 and 10 is probably good.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the binary thresholding</span>
<span class="sd">        calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True the code will stop at each hdu (i.e., exposure) and generate some diagnostic plots that show the</span>
<span class="sd">        computed lines and grid intersections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lst</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2,</span>
<span class="sd">        N) containing the (x,y) coordinates for the N intersections found in that hdu.</span>

<span class="sd">    lst</span>
<span class="sd">        A list containing the camera positions (VBI__005) of each corresponding hdu</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_intersections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Maybe pos_list should just get recorded in another field of all_intersections?</span>
    <span class="n">pos_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">gridData</span><span class="o">.</span><span class="n">data_hdus</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: getting intersections from camera position </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__005&#39;</span><span class="p">]))</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="n">do_single_frame</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                             <span class="n">rho_smooth</span><span class="o">=</span><span class="n">rho_smooth</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="n">binary_threshold</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="n">sigclip</span><span class="p">,</span> <span class="o">**</span><span class="n">hough_args</span><span class="p">)</span>
        <span class="n">intersections</span> <span class="o">=</span> <span class="n">find_intersections</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">debugh</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;binary.fits&#39;</span><span class="p">)</span>
            <span class="n">debugh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span>
            <span class="n">debugh</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__005&#39;</span><span class="p">]),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plot_intersections</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__005&#39;</span><span class="p">]))</span>
            <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: debug plots generated. Press enter to continue&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>

        <span class="n">int_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">intersections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">all_intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">int_list</span><span class="p">))</span>
        <span class="n">pos_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__005&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">all_intersections</span><span class="p">,</span> <span class="n">pos_list</span></div>


<div class="viewcode-block" id="generate_target_calibration"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.generate_target_calibration.html#VBI_Pipeline.TargetCalibration.generate_target_calibration">[docs]</a><span class="k">def</span> <span class="nf">generate_target_calibration</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span>
                                <span class="n">output</span><span class="o">=</span><span class="s1">&#39;Target_Calibration.fits&#39;</span><span class="p">,</span> <span class="n">bimode_choice</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find overlapping intersections and use them to compute sub-pixel offsets between pairs of hdus.</span>

<span class="sd">    The resulting offsets are then saved separate HDUs of a Data.FitsData object.</span>

<span class="sd">    As of right now this algorithm is a little dumb; it only finds the offsets relative to a single, reference hdu.</span>
<span class="sd">    In the future it should be possible to use the information from all hdus that overlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intsects : list</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2,</span>
<span class="sd">        N) containing the (x,y) WCS coordinates for the N intersections found in that hdu. Probably the output of</span>
<span class="sd">        collect_intersections()</span>

<span class="sd">    pos_list : list</span>
<span class="sd">        A list containing the camera positions (VBI__005) of each corresponding hdu. Probably the output of</span>
<span class="sd">        collect_intersections()</span>

<span class="sd">    refidx : int</span>
<span class="sd">        Index of the reference hdu to use. Index corresponds to the location in both intsects and pos_list</span>

<span class="sd">    dmax : float</span>
<span class="sd">        Any intersections with pixel locations less than dmax apart are considered to be the same intersection.</span>

<span class="sd">    header : astropy.io.fits.header.Header</span>
<span class="sd">        Header of the line grid data set used to compute this Target Calibration</span>

<span class="sd">    output : str</span>
<span class="sd">        Location to save the resulting Target Calibration. It&#39;s a little strange that this is in this function</span>
<span class="sd">        instead of main()</span>

<span class="sd">    bimode_choice : list</span>
<span class="sd">        List containing the automatic choice for potential bimodality in the (x, y) dimensions. Choice can be either</span>
<span class="sd">        1 or 2; 1 always corresponds to the mode closest to the global median.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If true then generate a plot called &quot;overlap.pdf&quot; that shows all the intersections with those used to compute</span>
<span class="sd">        the shifts circled in red.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lst</span>
<span class="sd">        Length N list where N is the number of hdus and the elements are numpy arrays with [x_shift, y_shift]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We&#39;ll call out these two error conditions explicitly because they would both otherwise result in a generic</span>
    <span class="c1">#  IndexError. Here we add some specificity.</span>
    <span class="n">numpos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intsects</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numpos</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;The lists of camera positions and intersections do not have the same length!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">refidx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpos</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;The reference position </span><span class="si">{}</span><span class="s1"> cannot be found in the intersection list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">refidx</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bimode_choice</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">bimode_choice</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bimode_choice</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpos</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bimode_choice</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numpos</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The list provided for bimode choice is the wrong length&#39;</span><span class="p">)</span>

    <span class="n">hdulist</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)]</span>
    <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__004&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">),</span> <span class="s1">&#39;Number of spatial steps&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="c1"># This dict contains all of the data needed by gen_debug_plots</span>
        <span class="n">debug</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;intsects&#39;</span><span class="p">:</span> <span class="n">intsects</span><span class="p">,</span>
                 <span class="s1">&#39;pos_list&#39;</span><span class="p">:</span> <span class="n">pos_list</span><span class="p">,</span>
                 <span class="s1">&#39;refidx&#39;</span><span class="p">:</span> <span class="n">refidx</span><span class="p">,</span>
                 <span class="s1">&#39;dmax&#39;</span><span class="p">:</span> <span class="n">dmax</span><span class="p">,</span>
                 <span class="s1">&#39;c_i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpos</span><span class="p">,</span>
                 <span class="s1">&#39;c_ref&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpos</span><span class="p">,</span>
                 <span class="s1">&#39;min_i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpos</span><span class="p">,</span>
                 <span class="s1">&#39;min_ref&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpos</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpos</span><span class="p">):</span>
        <span class="n">badshift</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">refidx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: skipping reference frame </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">shift_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">std_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">badshift</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># First, find the indices in intsects_* of the points that match b/t the ref frame and frame i.</span>
            <span class="c1">#  idx_i identifies all points in intsects[i] that match intsects[refidx]</span>
            <span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_ref</span> <span class="o">=</span> <span class="n">find_match_idx</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">refidx</span><span class="p">],</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">idx_ref</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reference and position </span><span class="si">{}</span><span class="s1"> do not have the same number of overlaps. This should &#39;</span>
                                 <span class="s1">&#39;never happen.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx_ref</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: WARNING: No overlaps found b/t positions </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                                      <span class="n">pos_list</span><span class="p">[</span><span class="n">refidx</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:  THIS IS PROBABLY BAD!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
                <span class="n">shift_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
                <span class="n">std_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
                <span class="n">badshift</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># An acceptable set of matching points was found</span>
                <span class="n">num_choices</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1"># This loop checks for a bimodal shift distribution, which can be caused if the shift is large</span>
                    <span class="c1">#  enough that some intersections can be associated with one shift and another with a different shift.</span>

                    <span class="k">if</span> <span class="n">num_choices</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="n">bimode_choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: Detected loop in bimode segregation. Reverting to manual selection.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
                        <span class="n">bimode_choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

                    <span class="n">c_i</span> <span class="o">=</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">idx_i</span><span class="p">]</span>
                    <span class="n">c_ref</span> <span class="o">=</span> <span class="n">intsects</span><span class="p">[</span><span class="n">refidx</span><span class="p">][:,</span> <span class="n">idx_ref</span><span class="p">]</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="n">c_i</span> <span class="o">-</span> <span class="n">c_ref</span>

                    <span class="c1"># Here&#39;s where we actually check for bimodality</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: finding shifts for camera pos </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">shift_px</span><span class="p">,</span> <span class="n">std_px</span><span class="p">,</span> <span class="n">ignore_idx</span> <span class="o">=</span> <span class="n">check_shifts</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">bimode_choice</span><span class="o">=</span><span class="n">bimode_choice</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">num_choices</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ignore_idx</span><span class="p">]):</span>
                        <span class="c1"># If there WAS bimodality the ignore_idx will be not empty and contain the indices of the mode</span>
                        <span class="c1">#  that should be ignored</span>
                        <span class="n">ignore_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;i_x&#39;</span><span class="p">:</span> <span class="n">idx_i</span><span class="p">[</span><span class="n">ignore_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                       <span class="s1">&#39;i_y&#39;</span><span class="p">:</span> <span class="n">idx_i</span><span class="p">[</span><span class="n">ignore_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                       <span class="s1">&#39;ref_x&#39;</span><span class="p">:</span> <span class="n">idx_ref</span><span class="p">[</span><span class="n">ignore_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                       <span class="s1">&#39;ref_y&#39;</span><span class="p">:</span> <span class="n">idx_ref</span><span class="p">[</span><span class="n">ignore_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]}</span>

                        <span class="c1"># Now re-run find_match_idx but don&#39;t count matches from the ignored mode</span>
                        <span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_ref</span> <span class="o">=</span> <span class="n">find_match_idx</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">refidx</span><span class="p">],</span> <span class="n">dmax</span><span class="p">,</span>
                                                        <span class="n">ignore_dict</span><span class="o">=</span><span class="n">ignore_dict</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="n">shift_wcs</span> <span class="o">=</span> <span class="n">shift_px</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]])</span>
                <span class="n">std_wcs</span> <span class="o">=</span> <span class="n">std_px</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> num intersetions: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> [x, y] shift (wcs): </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shift_wcs</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> [x, y] stdev (wcs): </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std_wcs</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> [x, y] shift (px): </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shift_px</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> [x, y] stdev (px): </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std_px</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">debug</span><span class="p">[</span><span class="s1">&#39;c_i&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_i</span>
                    <span class="n">debug</span><span class="p">[</span><span class="s1">&#39;c_ref&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_ref</span>

        <span class="n">shift_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">shift_px</span><span class="p">,</span> <span class="n">std_px</span><span class="p">))</span>
        <span class="n">ihdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">shift_data</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;AXIS1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Shift stddev [px]&#39;</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;AXIS2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Shift amount [px]&#39;</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__005&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BADSHFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">badshift</span><span class="p">,</span> <span class="s1">&#39;If True then the WCS solution is likely wrong!&#39;</span><span class="p">)</span>
        <span class="n">hdulist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ihdu</span><span class="p">)</span>

    <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">target_calibration</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">gen_debug_plots</span><span class="p">(</span><span class="o">**</span><span class="n">debug</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target_calibration</span></div>


<div class="viewcode-block" id="find_match_idx"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.find_match_idx.html#VBI_Pipeline.TargetCalibration.find_match_idx">[docs]</a><span class="k">def</span> <span class="nf">find_match_idx</span><span class="p">(</span><span class="n">intsects_i</span><span class="p">,</span> <span class="n">intsects_ref</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">ignore_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Identify intersections that are probably the same point and return their indices</span>

<span class="sd">    The radial distances between ALL intersections are computed and any less than ``dmax`` are considered to be the same</span>
<span class="sd">    points. Additionally, the algorithm ensures that a) only the minimum distance companion for each intersection is</span>
<span class="sd">    used, and b) that no intersections are double counted.</span>

<span class="sd">    The user can specify a set of match candidates to ignore via the ``ignore_dict`` keyword. This is useful if a</span>
<span class="sd">    bimodal distribution of match offsets is suspected.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intsects_i : `numpy.ndarray`</span>
<span class="sd">        Array of shape (2, M) containing the (X, Y) locations of the M intersections in the candidate image</span>

<span class="sd">    intsects_ref : `numpy.ndarray`</span>
<span class="sd">        Array of shape (2, N) containing the (X, Y) locations of the N intersections in the reference image</span>

<span class="sd">    dmax : float</span>
<span class="sd">        Any match candidates with a radial distance greater than dmax are immediately excluded from consideration</span>

<span class="sd">    ignore_dict : dict</span>
<span class="sd">        A dictionary with keys `i_x`, `i_y`, `ref_x`, and `ref_y` whose values are index arrays containing the match</span>
<span class="sd">        candidates to ignore. For each element, the match between (`i_x`, `i_y`) in the candidate frame and</span>
<span class="sd">        (`ref_x`, `ref_y`) in the reference frame will be considered bad, regardless of how close the two intersections</span>
<span class="sd">        are to each other.</span>

<span class="sd">    debug : dict or None</span>
<span class="sd">        If a dict is provided it will be updated with data useful to `gen_debug_plots`</span>

<span class="sd">    i : int</span>
<span class="sd">        The HDU index of the candidate frame. Only needed if ``debug`` is not None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.ndarray`</span>
<span class="sd">        The array that slices all matching points from intsects_i</span>

<span class="sd">    `numpy.ndarray`</span>
<span class="sd">        The array that slices all matching points from intsects_ref</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">intsects_i</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">intsects_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">diff_y</span> <span class="o">=</span> <span class="n">intsects_i</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">intsects_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">diff_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">diff_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Ignore any SPECIFIC MATCHES that have been previously been identified (by check_shifst()) as being incorrect.</span>
    <span class="k">if</span> <span class="n">ignore_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">diff_r</span><span class="p">[</span><span class="n">ignore_dict</span><span class="p">[</span><span class="s1">&#39;i_x&#39;</span><span class="p">],</span> <span class="n">ignore_dict</span><span class="p">[</span><span class="s1">&#39;ref_x&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">diff_r</span><span class="p">[</span><span class="n">ignore_dict</span><span class="p">[</span><span class="s1">&#39;i_y&#39;</span><span class="p">],</span> <span class="n">ignore_dict</span><span class="p">[</span><span class="s1">&#39;ref_y&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: median distance: </span><span class="si">{:6.4f}</span><span class="s1"> px&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">diff_r</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: stddev distance: </span><span class="si">{:6.4f}</span><span class="s1"> px&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">diff_r</span><span class="p">)))</span>

    <span class="c1"># By taking the minimum along each dimension (corresponding to the i&#39;th and ref positions) we are ensuring</span>
    <span class="c1">#  that no points are double counted, which might happen if points are within dmax of two reference points</span>
    <span class="n">min_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">diff_r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">diff_r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># We now make sure that the identified pairs are the same in each frame. This is done by only selecting</span>
    <span class="c1">#  intersections who&#39;s &#39;diff_r&#39; values are the same in both the reference and i&#39;th frame. It is possible</span>
    <span class="c1">#  that one of the frames has intersections that are not in the other, but are still within dmax of</span>
    <span class="c1">#  intersections in the other frame (especially if dmax is too large). Because they are unique points these</span>
    <span class="c1">#  intersections would have avoided the double-counting cull above, but are identified and removed here.</span>
    <span class="n">candidate_idx_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">candidate_idx_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_ref</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i_candidates</span> <span class="o">=</span> <span class="n">min_i</span><span class="p">[</span><span class="n">candidate_idx_i</span><span class="p">]</span>
    <span class="n">ref_candidates</span> <span class="o">=</span> <span class="n">min_ref</span><span class="p">[</span><span class="n">candidate_idx_ref</span><span class="p">]</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">i_candidates</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref_candidates</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">cidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">candidates</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">idx_i</span> <span class="o">=</span> <span class="n">candidate_idx_i</span><span class="p">[</span><span class="n">cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">idx_ref</span> <span class="o">=</span> <span class="n">candidate_idx_ref</span><span class="p">[</span><span class="n">cidx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">debug</span><span class="p">[</span><span class="s1">&#39;min_i&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_i</span>
        <span class="n">debug</span><span class="p">[</span><span class="s1">&#39;min_ref&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_ref</span>

    <span class="k">return</span> <span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_ref</span></div>

<div class="viewcode-block" id="check_shifts"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.check_shifts.html#VBI_Pipeline.TargetCalibration.check_shifts">[docs]</a><span class="k">def</span> <span class="nf">check_shifts</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">bimode_choice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given the distances between two sets of intersections, compute the actual shift values</span>

<span class="sd">    The shifts are computed as the median of all distances.</span>

<span class="sd">    Importantly, this function also checks for bimodality in the shift distribution. If detected then the user is</span>
<span class="sd">    prompted to choose which mode to use. This choice can be made automatically via ``auto_choise``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dists : `numpy.ndarray`</span>
<span class="sd">        Shape (2, N) array containing (X, Y) distances of all N matching point pairs</span>

<span class="sd">    bimode_choice : list</span>
<span class="sd">        List containing the automatic choice for potential bimodality in the (x, y) dimensions. Choice can be either</span>
<span class="sd">        1 or 2; 1 always corresponds to the mode closest to the global median.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.ndarray`</span>
<span class="sd">        Length 2 array containing the (X, Y) shifts</span>

<span class="sd">    `numpy.ndarray`</span>
<span class="sd">        Length 2 array containing the stddev of the (X, Y) shifts</span>

<span class="sd">    list</span>
<span class="sd">        List containing 2 `numpy.ndarray`s. If bimodality was detected each array contains indices of points not in the</span>
<span class="sd">        selected mode. Otherwise the arrays are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">stds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">bad_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">med</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">med</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span> <span class="c1"># Put an upper bound of all elements because if the median is really tiny</span>
                                       <span class="c1">#  then all elements might be larger than it.</span>
            <span class="n">shift_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">~</span><span class="n">idx</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">])]</span>
            <span class="n">std_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">~</span><span class="n">idx</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">])]</span>
            <span class="n">idx_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">~</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">idx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">shift_options</span> <span class="o">=</span> <span class="n">shift_options</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">std_options</span> <span class="o">=</span> <span class="n">std_options</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">idx_options</span> <span class="o">=</span> <span class="n">idx_options</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: bimodality detected in dimension </span><span class="si">{}</span><span class="s1">: medians = [</span><span class="si">{:.2f}</span><span class="s1">, </span><span class="si">{:.2f}</span><span class="s1">], numpoints = [</span><span class="si">{:}</span><span class="s1">, </span><span class="si">{:}</span><span class="s1">]&#39;</span><span class="o">.</span>\
                  <span class="nb">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shift_options</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shift_options</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">bimode_choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">choice</span> <span class="o">=</span> <span class="n">bimode_choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;*&#39;</span><span class="o">*</span><span class="mi">51</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dimension </span><span class="si">{}</span><span class="s1"> appears bimodal. Please select a shift:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; * A negative choice will force the shift to be exactly the median selected&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; * Choosing 0 will force the shift to be the global median</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:10}{:&gt;10}{:&gt;10}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;choice #&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:10}{:&gt;10}{:&gt;10}</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;numpoints&#39;</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:10}{:10.4f}{:10.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="s1">&#39;median&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_options</span><span class="p">)))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:10}{:10.4f}{:10.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="s1">&#39;stddev&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">std_options</span><span class="p">)))</span>

                <span class="n">choice</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">while</span> <span class="n">choice</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">choice</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;&gt; &#39;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">choice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>

            <span class="k">if</span> <span class="n">bimode_choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: automatically chose mode </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">choice</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{}</span><span class="s1">: chose mode </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">choice</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># In this case we just take the global stats and don&#39;t update bad_idx so that we don&#39;t rerun any</span>
                <span class="c1">#  intersection matching</span>
                <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Select one mode over another</span>
                <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift_options</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_options</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">choice</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If the choice is positive we update bad_idx so that intersection matching will be rerun</span>
                <span class="n">bad_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_options</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">stds</span><span class="p">,</span> <span class="n">bad_idx</span></div>

<div class="viewcode-block" id="gen_debug_plots"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.gen_debug_plots.html#VBI_Pipeline.TargetCalibration.gen_debug_plots">[docs]</a><span class="k">def</span> <span class="nf">gen_debug_plots</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c_ref</span><span class="p">,</span> <span class="n">min_i</span><span class="p">,</span> <span class="n">min_ref</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate 2 debug plots associated with the calculation of the camera shifts:</span>

<span class="sd">    1. &quot;overlap.pdf&quot; - A plot showing all grid images and all found intersections (yellow). The reference intersections</span>
<span class="sd">    are identified with green dots and all matching candidate intersections have red dots. Colored lines connecting</span>
<span class="sd">    these dots show the intersections identified as being the same. Each candidate image is given a different color.</span>

<span class="sd">    2. &quot;diffhist.pdf&quot; - A set of histograms for each candidate image. Each histogram shows the distribution of radial</span>
<span class="sd">    distances between ALL intersections in the reference and candidate images. ``dmax`` is marked with a vertical line.</span>

<span class="sd">    NOTE: For this function to work ALL intermediate functions in this module need to have been run with ``debug=True``.</span>
<span class="sd">    This ensures that all needed files exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intsects : list</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2, N)</span>
<span class="sd">        containing the (x,y) WCS coordinates for the N intersections found in that hdu. Probably the output of</span>
<span class="sd">        collect_intersections()</span>

<span class="sd">    pos_list : list</span>
<span class="sd">        A list containing the camera positions (VBI__005) of each corresponding hdu. Probably the output of</span>
<span class="sd">        collect_intersections()</span>

<span class="sd">    refidx : int</span>
<span class="sd">        Index of the reference hdu to use. Index corresponds to the location in both intsects and pos_list</span>

<span class="sd">    dmax : float</span>
<span class="sd">        Any intersections with pixel locations less than dmax apart are considered to be the same intersection.</span>

<span class="sd">    c_i : `numpy.ndarray`</span>
<span class="sd">        (2, M) shape array containing (x, y) coordinates of all matching points in the candidate image.</span>

<span class="sd">    c_ref : `numpy.ndarray`</span>
<span class="sd">        (2, M) shape array containing (x, y) coordinates of all matching points in the reference image.</span>

<span class="sd">    min_i : `numpy.ndarray`</span>
<span class="sd">        1D array containing the radial distance of the closest intersection to all intersections in the candidate image</span>

<span class="sd">    min_ref : `numpy.ndarray`</span>
<span class="sd">        1D array containing the radial distance of the closest intersection to all intersections in the reference image</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: Generating debug plots&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
    <span class="n">overlap_ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">diffhist_pp</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">(</span><span class="s1">&#39;diffhist.pdf&#39;</span><span class="p">)</span>
    <span class="n">colorlist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;#e41a1c&#39;</span><span class="p">,</span><span class="s1">&#39;#377eb8&#39;</span><span class="p">,</span><span class="s1">&#39;#4daf4a&#39;</span><span class="p">,</span><span class="s1">&#39;#984ea3&#39;</span><span class="p">,</span><span class="s1">&#39;#ff7f00&#39;</span><span class="p">,</span><span class="s1">&#39;#ffff33&#39;</span><span class="p">,</span><span class="s1">&#39;#a65628&#39;</span><span class="p">,</span><span class="s1">&#39;#f781bf&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsects</span><span class="p">)):</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bdata</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">data</span>
        <span class="n">numx</span><span class="p">,</span> <span class="n">numy</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">bwx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numx</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">bwy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numy</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">overlap_ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span>
                          <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">bwx</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">bwx</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">min</span><span class="p">()],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">overlap_ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">refidx</span><span class="p">:</span>
            <span class="n">overlap_ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
                            <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">overlap_ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap_ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colorlist</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
                            <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">overlap_ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">c_i</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_i</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
            <span class="n">overlap_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">c_i</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_ref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">c_i</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">c_ref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colorlist</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">bdata</span>
        <span class="k">del</span> <span class="n">binary</span>

        <span class="c1">#####################</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">refidx</span><span class="p">:</span>
            <span class="n">diffhist_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

            <span class="n">axi</span> <span class="o">=</span> <span class="n">diffhist_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
            <span class="n">pidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_i</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">dmax</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">)</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">axi</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_i</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="n">pidx</span><span class="p">],</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="n">axi</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">nidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">axi</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;[</span><span class="si">{:4.2f}</span><span class="s1">, </span><span class="si">{:4.2f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">nidx</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">nidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">transform</span><span class="o">=</span><span class="n">axi</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
                    <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">axi</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;VBI__005 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="n">axref</span> <span class="o">=</span> <span class="n">diffhist_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
            <span class="n">pidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_ref</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">dmax</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">)</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">axref</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_ref</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="n">pidx</span><span class="p">],</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="n">axref</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">nidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">axref</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;[</span><span class="si">{:4.2f}</span><span class="s1">, </span><span class="si">{:4.2f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">nidx</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">nidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">transform</span><span class="o">=</span><span class="n">axref</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
                       <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">axref</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;ref, VBI__005 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">refidx</span><span class="p">))</span>
            <span class="n">diffhist_pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">diffhist_fig</span><span class="p">)</span>

    <span class="n">overlap_ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
    <span class="n">overlap_ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;overlap.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">overlap_ax</span><span class="o">.</span><span class="n">figure</span><span class="p">)</span>
    <span class="n">diffhist_pp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

    <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">gen2</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;Target_Calibration.fits&#39;</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">X_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Y_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">intsects</span><span class="p">:</span>
        <span class="n">X_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">Y_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">X_lst</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">Y_lst</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">startsize</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: starting with </span><span class="si">{}</span><span class="s1"> intersections&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">startsize</span><span class="p">))</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">dR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># After the next three steps all points deemed to be the &#39;same&#39; within the limit of dmax will have their</span>
    <span class="c1"># locations updated to the average of all intersection points.</span>
    <span class="c1">#  In other words, if two HDUs have an point with x locations 10 and 11 then the points new location will be 10.5</span>
    <span class="c1">#  in both frames. In this way the final shifts will be to a global average.</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dR</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">)</span>
    <span class="n">dX</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">dY</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># This step essentially halfs the absolute difference between the coordinates of overlapping points</span>
    <span class="n">dX_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dY_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># And this step brings each pair of overlapping points (there will be exactly 2 per intersection) to the same value.</span>
    <span class="n">X</span> <span class="o">-=</span> <span class="n">dX_avg</span>
    <span class="n">Y</span> <span class="o">-=</span> <span class="n">dY_avg</span>

    <span class="c1"># Find the unique set</span>
    <span class="n">xuidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">yuidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xuidx</span> <span class="o">==</span> <span class="n">yuidx</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xuidx</span><span class="p">,</span> <span class="n">yuidx</span><span class="p">)</span>
        <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;OH SHIT&#39;</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">xuidx</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">yuidx</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: found </span><span class="si">{}</span><span class="s1"> overlapping points&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">startsize</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="n">xshifts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">yshifts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">hdulist</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">()]</span>
    <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__004&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">),</span> <span class="s1">&#39;Number of spatial steps&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">points</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">):</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">numx</span><span class="p">,</span> <span class="n">numy</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">bwx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numx</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span>
            <span class="n">bwy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numy</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span>
                      <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">bwx</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">bwx</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">min</span><span class="p">()],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">xp</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">yp</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># TODO: There probably shouldn&#39;t be nan&#39;s here at all</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">yp</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">xp</span><span class="p">],</span> <span class="p">[</span><span class="n">yp</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">-</span> <span class="n">X</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">yp</span> <span class="o">-</span> <span class="n">Y</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="n">dy</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="c1"># print(&#39;Skpping&#39;,xp,yp)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">xp</span><span class="p">],</span> <span class="p">[</span><span class="n">yp</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> num overlaps: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: camera pos </span><span class="si">{:}</span><span class="s1"> [x, y] shift: </span><span class="si">{:5.4f}</span><span class="s1">, </span><span class="si">{:5.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ys</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: camera pos </span><span class="si">{:}</span><span class="s1"> [x, y] stdev: </span><span class="si">{:5.4f}</span><span class="s1">, </span><span class="si">{:5.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ys</span><span class="p">)))</span>
        <span class="n">ihdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">()</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__004&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI__005&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CSHIFT1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CSHIFT2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SHTSTD1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SHTSTD2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">hdulist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ihdu</span><span class="p">)</span>

        <span class="n">xshifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
        <span class="n">yshifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

    <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;overlap.pdf&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xshifts</span><span class="p">,</span> <span class="n">yshifts</span>


<div class="viewcode-block" id="make_binary_gauss"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.make_binary_gauss.html#VBI_Pipeline.TargetCalibration.make_binary_gauss">[docs]</a><span class="k">def</span> <span class="nf">make_binary_gauss</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an array to a binary image using a gaussian smoothing method.</span>

<span class="sd">    This method is designed to highlight features with high spatial frequency (i.e., grid lines). The algorithm is:</span>

<span class="sd">     1. Create a smooth version of the input data</span>
<span class="sd">     2. Subtract the smooth and un-smooth data</span>
<span class="sd">     3. Use Otsu&#39;s method to threshold the resulting image</span>
<span class="sd">     4. Apply the threshold to the difference image.</span>

<span class="sd">    The idea here is that the interesting features have been smoothed out of the smooth image and thus the difference</span>
<span class="sd">    image has very strong signal at these features. To work properly the amount of blur should be very close to the</span>
<span class="sd">    pixel width of the features to be extracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        Input data array</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Width (in px units) of smoothing kernel. See above; this should be close to the size of the feature to be</span>
<span class="sd">        extracted.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the thresholding calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True, write out the binary image for later inspection. It will be called &#39;binary.fits&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The binary image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: generating binary image with smoothing kernel </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">sigma</span><span class="p">))</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">gauss</span> <span class="o">-</span> <span class="n">data</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">count_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">binary_threshold</span> <span class="ow">or</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binary_threshold</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Binary threshold fraction (</span><span class="si">{:5.3e}</span><span class="s1">) out of bounds. Refining Otsu to remove outliers&#39;</span><span class="o">.</span> \
              <span class="nb">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">binary_threshold</span> <span class="ow">or</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binary_threshold</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binary_threshold</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">])</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">count_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">:  threshold fraction = </span><span class="si">{:5.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: cleaning up low outliers&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">diff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: cleaning up high outliers&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">diff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;diff.fits&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;binary.fits&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">binary</span></div>


<div class="viewcode-block" id="do_single_frame"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.do_single_frame.html#VBI_Pipeline.TargetCalibration.do_single_frame">[docs]</a><span class="k">def</span> <span class="nf">do_single_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">theta_window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">rho_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">theta_min_dist</span><span class="o">=</span><span class="mi">1500</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
                    <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the equations for all the horizontal and vertical lines in a data array.</span>

<span class="sd">    The lines are found using a Hough Transform and are thus parametrized by (theta, rho). Before the Hough Transform</span>
<span class="sd">    the data are converted to a binary array and the actual transform is done using skimage.</span>

<span class="sd">    The lines discovered by the transform are constrained to be within +/- 20 degrees of horizontal or vertical.</span>
<span class="sd">    Finally, any lines with angles that significantly deviate from the group average are removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        Input data array. Should be 2-d</span>

<span class="sd">    gauss_sigma : float</span>
<span class="sd">        Width of smoothing kernel used to construct a binary image from the input data. Should be slightly less than</span>
<span class="sd">        the pixel width of the grid lines.</span>

<span class="sd">    theta_window : float</span>
<span class="sd">        Window in radians around (before and after) each peak angle within which to search for peaks in rho.</span>

<span class="sd">    rho_window : float</span>
<span class="sd">        Window in pixels around (before and after) each peak rho value within which to refine location of peak angle.</span>

<span class="sd">    theta_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in theta.</span>

<span class="sd">    rho_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in rho. This parameter is highly dependent</span>
<span class="sd">        on the pixel scale of the grid lines.</span>

<span class="sd">    rho_smooth : float</span>
<span class="sd">        Sigma of smoothing kernel used to remove noise from the rho rss. Something b/t 5 and 10 is probably good.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the binary thresholding</span>
<span class="sd">        calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True the code will stop at each hdu (i.e., exposure) and generate some diagnostic plots that show the</span>
<span class="sd">        computed lines and grid intersections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        (rho, theta) where each element is an ndarray with the associated values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;data.fits&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="n">make_binary_gauss</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="n">binary_threshold</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="n">sigclip</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: performing Hough transform&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">skit</span><span class="o">.</span><span class="n">hough_line</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1500</span><span class="p">))</span>
    <span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">theta_min_dist</span><span class="p">)</span>
    <span class="n">peak_theta</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: found peaks in theta RSS at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">idx</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: most prominent angles: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">peak_theta</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: difference: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">peak_theta</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rss</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">theta</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">peak_theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;trss.pdf&#39;</span><span class="p">)</span>

    <span class="n">grid_theta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">grid_rho</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peak_theta</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:}</span><span class="s2">: finding rho&#39;s for angle </span><span class="si">{:5.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">t</span><span class="p">))</span>
        <span class="n">tidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">theta_window</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rrss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="n">tidx</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">srrss</span> <span class="o">=</span> <span class="n">spnd</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">rrss</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span><span class="n">srrss</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">peak_rho</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">srrss</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rangeid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rrss</span> <span class="o">&gt;</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rrss</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="n">rangeid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">rho</span><span class="p">[</span><span class="n">rangeid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">srrss</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rrss</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">rho</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">peak_rho</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>

            <span class="n">ridx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rho</span> <span class="o">-</span> <span class="n">peak_rho</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">rho_window</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">trss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">ridx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">tidx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">tridx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">trss</span><span class="p">)]</span>
            <span class="n">final_theta</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">tidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">tidx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">trss</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">tridx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">grid_rho</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak_rho</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">grid_theta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_theta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;rrss.pdf&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">grid_theta</span><span class="p">,</span> <span class="n">grid_rho</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">pidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pidx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">pidx</span><span class="p">],</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;im.pdf&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_rho</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_intersections"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.find_intersections.html#VBI_Pipeline.TargetCalibration.find_intersections">[docs]</a><span class="k">def</span> <span class="nf">find_intersections</span><span class="p">(</span><span class="n">sklines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a list of intersection between horizontal and vertical input lines.</span>

<span class="sd">    Lines are pre-screened so that intersections near infinity within vertical and horizontal line sets are ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sklines : tuple</span>
<span class="sd">        An (theta, rho) tuple where each element is a numpy.ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Shape (2,N) corresponding to (x,y) coordinates for each of the N intersections</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inter_lst</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">sklines</span>
    <span class="n">hidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">theta</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">vidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">theta</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ht</span><span class="p">,</span> <span class="n">hr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="n">rho</span><span class="p">[</span><span class="n">hidx</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">vt</span><span class="p">,</span> <span class="n">vr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">vidx</span><span class="p">],</span> <span class="n">rho</span><span class="p">[</span><span class="n">vidx</span><span class="p">]):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">vr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span> <span class="o">-</span> <span class="n">hr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">vt</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ht</span> <span class="o">-</span> <span class="n">vt</span><span class="p">)</span>
            <span class="n">hy</span> <span class="o">=</span> <span class="p">(</span><span class="n">hr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span> <span class="o">-</span> <span class="n">vr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ht</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ht</span> <span class="o">-</span> <span class="n">vt</span><span class="p">)</span>

            <span class="n">inter_lst</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">hy</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">inter_lst</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>


<span class="k">def</span> <span class="nf">plot_intersections</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">imagefile</span><span class="o">=</span><span class="s1">&#39;binary.fits&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a debug plot that shows all of the found intersections on top of the input image.</span>

<span class="sd">    Actually, it&#39;s the binary version of the input image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intersections : numpy.ndarray</span>
<span class="sd">        Shape (2,N), the x,y coordinates of intersections</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The resulting plot is written to &#39;intersections.pdf&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">imagefile</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intersections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;intersections.pdf&#39;</span><span class="p">)</span>

    <span class="k">return</span>


<span class="k">def</span> <span class="nf">intersections_to_ds9</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Quick script to generate a ds9 region file from a list of line intersections&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Region file format: DS9 version 4.1</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s1">&#39;global color=red dashlist=8 3 width=4 font=&quot;helvetica 10 normal roman&quot; select=1 highlite=1 dash=0 &#39;</span>
                <span class="s1">&#39;fixed=0 edit=1 move=1 delete=1 include=1 source=1</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;physical</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intersections</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;circle(</span><span class="si">{:8.5f}</span><span class="s1">,</span><span class="si">{:8.5f}</span><span class="s1">,20)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intersections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">compare_gens</span><span class="p">(</span><span class="n">rdx_dir</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">refidx</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">VBI_Pipeline</span> <span class="kn">import</span> <span class="n">ScienceCalibration</span><span class="p">,</span> <span class="n">ApplyTargetCalibration</span>

    <span class="n">pGD1</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/linegrid_proc.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rdx_dir</span><span class="p">))</span>
    <span class="n">pGD2</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/linegrid_proc.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rdx_dir</span><span class="p">))</span>

    <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">collect_intersections</span><span class="p">(</span><span class="n">pGD1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="n">rho_min_dist</span><span class="p">)</span>

    <span class="n">generate_target_calibration</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;TC1.fits&#39;</span><span class="p">,</span> <span class="n">refidx</span><span class="o">=</span><span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>
    <span class="n">gen2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;TC2.fits&#39;</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>

    <span class="n">TC1</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;TC1.fits&#39;</span><span class="p">)</span>
    <span class="n">TC2</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;TC2.fits&#39;</span><span class="p">)</span>

    <span class="n">ScienceCalibration</span><span class="o">.</span><span class="n">generate_science_data</span><span class="p">(</span><span class="n">pGD1</span><span class="p">,</span> <span class="n">TC1</span><span class="p">)</span>
    <span class="n">ScienceCalibration</span><span class="o">.</span><span class="n">generate_science_data</span><span class="p">(</span><span class="n">pGD2</span><span class="p">,</span> <span class="n">TC2</span><span class="p">)</span>

    <span class="n">ApplyTargetCalibration</span><span class="o">.</span><span class="n">stitch_FitsData</span><span class="p">(</span><span class="n">pGD1</span><span class="p">)</span><span class="o">.</span><span class="n">write_out</span><span class="p">(</span><span class="s1">&#39;spGD1.fits&#39;</span><span class="p">)</span>
    <span class="n">ApplyTargetCalibration</span><span class="o">.</span><span class="n">stitch_FitsData</span><span class="p">(</span><span class="n">pGD2</span><span class="p">)</span><span class="o">.</span><span class="n">write_out</span><span class="p">(</span><span class="s1">&#39;spGD2.fits&#39;</span><span class="p">)</span>

    <span class="k">return</span>

<div class="viewcode-block" id="command_line"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.command_line.html#VBI_Pipeline.TargetCalibration.command_line">[docs]</a><span class="k">def</span> <span class="nf">command_line</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">pkg_resources</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">configparser</span> <span class="kn">import</span> <span class="n">ConfigParser</span>
    <span class="kn">from</span> <span class="nn">VBI_Pipeline</span> <span class="kn">import</span> <span class="n">VBIPipeline</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Run the VBI Pipeline&#39;s Target Calibration module. This is a direct hook into TargetCalibration.main()&quot;</span>
                    <span class="s2">&quot;and all kwargs are exposed as command line options&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;grid_dir&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Directory containing raw GOS grid images&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Location to save Target Calibration FITS object&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;--force&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Overwrite output&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-D&#39;</span><span class="p">,</span> <span class="s1">&#39;--dark-cal&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Location of Dark Calibration object FITS file. If none is provided &#39;</span>
                                                 <span class="s1">&#39;then no dark correction will be done.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-G&#39;</span><span class="p">,</span> <span class="s1">&#39;--gain-cal&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Location of Gain Calibration object FITS file. If none is provided &#39;</span>
                                                 <span class="s1">&#39;then no gain correction will be done.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="s1">&#39;--gauss-sigma&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Width of smoothing kernel used to construct a binary image from &#39;</span>
                                                    <span class="s1">&#39;the input data. Should be slightly less than the pixel width of &#39;</span>
                                                    <span class="s1">&#39;the grid lines.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-d&#39;</span><span class="p">,</span> <span class="s1">&#39;--dmax&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Any intersections with pixel locations less than dmax apart are considered&#39;</span>
                                             <span class="s1">&#39; to be the same intersection.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="s1">&#39;--rho-min-dist&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Minimum distance (in Hough space coordinates) allowed between &#39;</span>
                                                     <span class="s1">&#39;peaks in rho. This parameter is highly dependent on the pixel &#39;</span>
                                                     <span class="s1">&#39;scale of the grid lines.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--refidx&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Index of the reference hdu to use. Index corresponds to the location in &#39;</span>
                                               <span class="s1">&#39;both intsects and pos_list&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-R&#39;</span><span class="p">,</span> <span class="s1">&#39;--rho-smooth&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Sigma of smoothing kernel used to remove noise from the rho rss. &#39;</span>
                                                   <span class="s1">&#39;Something b/t 5 and 10 is probably good.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-t&#39;</span><span class="p">,</span> <span class="s1">&#39;--binary-threshold&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Min percentage of pixels to be on one side of the Otsu &#39;</span>
                                                         <span class="s1">&#39;threshold when constructing the binary image. If the &#39;</span>
                                                         <span class="s1">&#39;percentage of pixels above the threshold is outside the range &#39;</span>
                                                         <span class="s1">&#39;(binary_threshold, 1 - binary_threshold), then some cleaning &#39;</span>
                                                         <span class="s1">&#39;of outlying pixels is performed.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-s&#39;</span><span class="p">,</span> <span class="s1">&#39;--sigclip&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Any pixels beyond sigclip standard deviations from the mean are &#39;</span>
                                                <span class="s1">&#39;excluded from the binary thresholding calculation.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-p&#39;</span><span class="p">,</span> <span class="s1">&#39;--debug&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;If True the code will stop at each hdu (i.e., camera position) and &#39;</span>
                                              <span class="s1">&#39;generate some diagnostic plots that show the computed lines and &#39;</span>
                                              <span class="s1">&#39;grid intersections.&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">force</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> already exists. To overwrite, use the &#39;-f&#39; option.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_dir</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> does not appear to be a valid directory&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_dir</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">kwpars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gauss_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;dmax&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_min_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;refidx&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_smooth&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_threshold&#39;</span><span class="p">,</span> <span class="s1">&#39;sigclip&#39;</span><span class="p">,</span> <span class="s1">&#39;debug&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">kwpars</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">gridData</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">AlignmentData</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_dir</span><span class="p">)</span>
    <span class="n">instrument</span> <span class="o">=</span> <span class="n">gridData</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;INSTRUME&#39;</span><span class="p">]</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
    <span class="n">config</span><span class="p">[</span><span class="s1">&#39;TargetCalibration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
    <span class="n">defaults</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;data/defaults.ini&#39;</span><span class="p">))</span>

    <span class="n">runkw</span> <span class="o">=</span> <span class="n">VBIPipeline</span><span class="o">.</span><span class="n">get_intermediate_kwargs</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;TargetCalibration&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_dir&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">dark_cal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">runkw</span><span class="p">[</span><span class="s1">&#39;dark_cal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">dark_cal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">gain_cal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">runkw</span><span class="p">[</span><span class="s1">&#39;gain_cal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">gain_cal</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calling TargetCalibration.main</span><span class="se">\n\t</span><span class="s1">with args [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">]</span><span class="se">\n\t</span><span class="s1">and kwargs </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_dir</span><span class="p">,</span>
                                                                                         <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span>
                                                                                         <span class="n">runkw</span><span class="p">))</span>

    <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">grid_dir</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">runkw</span><span class="p">)</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <div class="left-footer">
         &copy; 2020, Arthur Eigenbrot
       <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
    </div>
   
    <div class="right-footer">
      Last updated on 13 Jan 2020.
    </div>
    <div class="centre-footer">
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1
    </div>
  </div>
</footer>
  </body>
</html>