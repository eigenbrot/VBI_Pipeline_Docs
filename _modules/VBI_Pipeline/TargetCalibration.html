
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>VBI_Pipeline.TargetCalibration &#8212; VBI_Pipeline v0.2.0</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700" type="text/css" />
    <link rel="stylesheet" href="../../_static/dkist.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/favico.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="col-md-3 navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://nso.edu"><img src="../../_static/img/NSOlogo.gif">
        </a>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav hidden">
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">VBI Pipeline Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthrough.html">Data Reduction Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config_file.html">Configuration File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Reference/API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>
          
            <ul class="nav navbar-nav navbar-left">
              <li><a href="http://dkist.nso.edu/">DKIST</a></li>
              <li><a href="http://docs.cadair.com/devdocs">DC Developer Guide</a></li>
              <li><a href="http://docs.cadair.com/datarate">DKIST Data Rate</a></li>
              <li><a href="http://docs.cadair.com/datamodel">DKIST Data Model</a></li>
            </ul>
          
          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">

    <div class="col-md-3"><div id="side-logo" >
            <a href="http://dkist.nso.edu">
                <img src="../../_static/img/DKISTLogo-Medium.jpg">
            </a>
        </div><div id="sidebar" class="bs-sidenav" role="complementary">
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">VBI Pipeline Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthrough.html">Data Reduction Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config_file.html">Configuration File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Reference/API</a></li>
</ul>

            
        </div>
    </div>

    <div class="col-md-9 content">
      
  <h1>Source code for VBI_Pipeline.TargetCalibration</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span> <span class="k">as</span> <span class="n">pyfits</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">peakutils</span> <span class="k">as</span> <span class="nn">pku</span>
<span class="kn">import</span> <span class="nn">skimage.transform</span> <span class="k">as</span> <span class="nn">skit</span>
<span class="kn">import</span> <span class="nn">skimage.filters</span> <span class="k">as</span> <span class="nn">skif</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">spnd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">VBI_Pipeline</span> <span class="k">import</span> <span class="n">Data</span><span class="p">,</span> <span class="n">generic</span><span class="p">,</span> <span class="n">FLUSH</span>
<span class="kn">from</span> <span class="nn">VBI_Pipeline.tag</span> <span class="k">import</span> <span class="n">tag</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;classic&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.main.html#VBI_Pipeline.TargetCalibration.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">grid_dir</span><span class="p">,</span> <span class="n">outname</span><span class="p">,</span> <span class="n">dark_cal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gain_cal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mf">15.</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
         <span class="n">refidx</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a TargetCalibration (i.e., wcs sub-pixel offsets) given an input linegrid image.</span>

<span class="sd">    Pre-processing by dark and gain Calibration products can be induced by specifying the corresponding FitsData</span>
<span class="sd">    objects. The gain calibration, in particular, is extremely necessary for good analysis.</span>

<span class="sd">    The 4 special parameters exposed here (gauss_sigma, dmax, rho_min_dist, and refidx) vary greatly whether considering</span>
<span class="sd">    Blue or Red camera data. Watch out!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid_dir : str</span>
<span class="sd">        Location of directory containing the linegrid data</span>

<span class="sd">    outname : str</span>
<span class="sd">        The path of the resulting Target Calibration Data.FitsData file</span>

<span class="sd">    dark_cal : Data.FitsData</span>
<span class="sd">        A Dark Calibration object</span>

<span class="sd">    gain_cal : Data.FitsData</span>
<span class="sd">        A Gain Calibration object</span>

<span class="sd">    gauss_sigma : float</span>
<span class="sd">        Width of smoothing kernel used to construct a binary image from the input data. Should be slightly less than</span>
<span class="sd">        the pixel width of the grid lines.</span>

<span class="sd">    dmax : float</span>
<span class="sd">        Any intersections with pixel locations less than dmax apart are considered to be the same intersection.</span>

<span class="sd">    rho_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in rho. This parameter is highly dependent</span>
<span class="sd">        on the pixel scale of the grid lines.</span>

<span class="sd">    refidx : int</span>
<span class="sd">        Index of the reference hdu to use. Index corresponds to the location in both intsects and pos_list</span>

<span class="sd">    rho_smooth : float</span>
<span class="sd">        Sigma of smoothing kernel used to remove noise from the rho rss. Something b/t 5 and 10 is probably good.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the binary thresholding</span>
<span class="sd">        calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True the code will stop at each hdu (i.e., camera position) and generate some diagnostic plots that show the</span>
<span class="sd">        computed lines and grid intersections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Data.FitsData</span>
<span class="sd">        A Target Calibration. Note that this calibration does not actually have any data; all of the info is stored</span>
<span class="sd">        in header values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">pkl_name</span> <span class="o">=</span> <span class="n">load_hough_pickle</span><span class="p">(</span><span class="n">outname</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">intersections</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;grid_proc.fits&#39;</span><span class="p">):</span>
        <span class="n">gridData</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">AlignmentData</span><span class="p">(</span><span class="n">grid_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dark_cal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: doing Dark Correction&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
            <span class="n">generic</span><span class="o">.</span><span class="n">dark_correction</span><span class="p">(</span><span class="n">gridData</span><span class="p">,</span> <span class="n">dark_cal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">FLUSH</span><span class="p">:</span>
                <span class="n">gridData</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">gain_cal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: doing Gain Correction&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
            <span class="n">generic</span><span class="o">.</span><span class="n">gain_correction</span><span class="p">(</span><span class="n">gridData</span><span class="p">,</span> <span class="n">gain_cal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">FLUSH</span><span class="p">:</span>
                <span class="n">gridData</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: averaging data&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">proc_gridData</span> <span class="o">=</span> <span class="n">generic</span><span class="o">.</span><span class="n">average_FitsData</span><span class="p">(</span><span class="n">gridData</span><span class="p">)</span>

        <span class="c1"># skimage likes working on images with values -1 to 1</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">proc_gridData</span><span class="o">.</span><span class="n">data_hdus</span><span class="p">:</span>
            <span class="n">h</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">)])</span>
            <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">procname</span> <span class="o">=</span> <span class="s1">&#39;grid_proc.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_dir</span><span class="p">)</span>
        <span class="n">proc_gridData</span><span class="o">.</span><span class="n">write_out</span><span class="p">(</span><span class="n">procname</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: saved processed linegrid image as </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">procname</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;grid_proc.fits&#39;</span><span class="p">):</span>
        <span class="n">proc_gridData</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;grid_proc.fits&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">intersections</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: finding line intersections&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span> <span class="o">=</span> <span class="n">collect_intersections</span><span class="p">(</span><span class="n">proc_gridData</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span>
                                                        <span class="n">rho_smooth</span><span class="o">=</span><span class="n">rho_smooth</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="n">binary_threshold</span><span class="p">,</span>
                                                        <span class="n">sigclip</span><span class="o">=</span><span class="n">sigclip</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: saving hough pickle to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pkl_name</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pkl_name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: generating target calibration&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
    <span class="n">target_calibration</span> <span class="o">=</span> <span class="n">generate_target_calibration</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">proc_gridData</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="n">output</span><span class="o">=</span><span class="n">outname</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target_calibration</span></div>


<div class="viewcode-block" id="load_hough_pickle"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.load_hough_pickle.html#VBI_Pipeline.TargetCalibration.load_hough_pickle">[docs]</a><span class="k">def</span> <span class="nf">load_hough_pickle</span><span class="p">(</span><span class="n">outname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load a previously-computed set of intersections and position list.</span>

<span class="sd">    This can save a huge amount of time by bypassing the hough transform steps if all that&#39;s needed is to, e.g., change</span>
<span class="sd">    the value of dmax.</span>

<span class="sd">    This is a separate function for now (rather than just being in main) because it might have some sanity checks in the</span>
<span class="sd">    future.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    outname : str</span>
<span class="sd">        The path to the final TargetCalibration object. This is used to auto-generate the saved intersection filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lst or None</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2,</span>
<span class="sd">        N) containing the (x,y) corrdinates for the N intersections found in that hdu. If no file is found then None is</span>
<span class="sd">        returned.</span>

<span class="sd">    lst or None</span>
<span class="sd">        A list containing the camera positions (VBI_005) of each corresponding hdu. If no save file was found then None</span>
<span class="sd">        is returned.</span>

<span class="sd">    str</span>
<span class="sd">        The name of the loaded/saved intersection/position file. Data are saved with python&#39;s pickle framework.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pkl_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_houghres.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pkl_name</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: found previous hough pickle at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pkl_name</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pkl_name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">intersections</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">pkl_name</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pkl_name</span></div>


<div class="viewcode-block" id="collect_intersections"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.collect_intersections.html#VBI_Pipeline.TargetCalibration.collect_intersections">[docs]</a><span class="k">def</span> <span class="nf">collect_intersections</span><span class="p">(</span><span class="n">gridData</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                          <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                          <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">hough_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a list grid intersection points for each hdu in the input data.</span>

<span class="sd">    The general algorithm for each hdu is:</span>

<span class="sd">     1. Create a binary image</span>
<span class="sd">     2. Find grid lines using the Hough Transform</span>
<span class="sd">     3. Compute the intersections of all of the discovered lines</span>

<span class="sd">    See associated helper functions for more detailed information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gridData : Data.FitsData</span>
<span class="sd">        Data object containing a linegrid image or series thereof</span>

<span class="sd">    rho_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in rho. This parameter is highly dependent</span>
<span class="sd">        on the pixel scale of the grid lines.</span>

<span class="sd">    gauss_sigma : float</span>
<span class="sd">        Width of smoothing kernel used to construct a binary image from the input data. Should be slightly less than</span>
<span class="sd">        the pixel width of the grid lines.</span>

<span class="sd">    rho_smooth : float</span>
<span class="sd">        Sigma of smoothing kernel used to remove noise from the rho rss. Something b/t 5 and 10 is probably good.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the binary thresholding</span>
<span class="sd">        calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True the code will stop at each hdu (i.e., exposure) and generate some diagnostic plots that show the</span>
<span class="sd">        computed lines and grid intersections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lst</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2,</span>
<span class="sd">        N) containing the (x,y) corrdinates for the N intersections found in that hdu.</span>

<span class="sd">    lst</span>
<span class="sd">        A list containing the camera positions (VBI_005) of each corresponding hdu</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_intersections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Maybe pos_list should just get recorded in another field of all_intersections?</span>
    <span class="n">pos_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">gridData</span><span class="o">.</span><span class="n">data_hdus</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: getting intersections from camera position </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_005&#39;</span><span class="p">]))</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="n">do_single_frame</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                             <span class="n">rho_smooth</span><span class="o">=</span><span class="n">rho_smooth</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="n">binary_threshold</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="n">sigclip</span><span class="p">,</span> <span class="o">**</span><span class="n">hough_args</span><span class="p">)</span>
        <span class="n">intersections</span> <span class="o">=</span> <span class="n">find_intersections</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">debugh</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;binary.fits&#39;</span><span class="p">)</span>
            <span class="n">debugh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span>
            <span class="n">debugh</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_005&#39;</span><span class="p">]),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plot_intersections</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_005&#39;</span><span class="p">]))</span>
            <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: debug plots generated. Press enter to continue&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>

        <span class="n">int_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">],</span>
                    <span class="p">(</span><span class="n">intersections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">]]</span>
        <span class="n">all_intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">int_list</span><span class="p">))</span>
        <span class="n">pos_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_005&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">all_intersections</span><span class="p">,</span> <span class="n">pos_list</span></div>


<div class="viewcode-block" id="generate_target_calibration"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.generate_target_calibration.html#VBI_Pipeline.TargetCalibration.generate_target_calibration">[docs]</a><span class="k">def</span> <span class="nf">generate_target_calibration</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span>
                                <span class="n">output</span><span class="o">=</span><span class="s1">&#39;Target_Calibration.fits&#39;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find overlapping intersetions and use them to compute sub-pixel offsets between pairs of hdus.</span>

<span class="sd">    The resulting offsets are then saved in the metadata (i.e., header) of a data-less Data.FitsData object.</span>

<span class="sd">    As of right now this algorithm is a little dumb; it only finds the offsets relative to a single, reference hdu.</span>
<span class="sd">    In the future it should be possible to use the information from all hdus that overlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intsects : tuple</span>
<span class="sd">        Each element of this list corresponds to a single input hdu and contains a numpy array of shape (2,</span>
<span class="sd">        N) containing the (x,y) WCS coordinates for the N intersections found in that hdu. Probably the output of</span>
<span class="sd">        collect_intersections()</span>

<span class="sd">    pos_list : list</span>
<span class="sd">        A list containing the camera positions (VBI_005) of each corresponding hdu. Probably the output of</span>
<span class="sd">        collect_intersections()</span>

<span class="sd">    refidx : int</span>
<span class="sd">        Index of the reference hdu to use. Index corresponds to the location in both intsects and pos_list</span>

<span class="sd">    dmax : float</span>
<span class="sd">        Any intersections with pixel locations less than dmax apart are considered to be the same intersection.</span>

<span class="sd">    header : astropy.io.fits.header.Header</span>
<span class="sd">        Header of the line grid data set used to compute this Target Calibration</span>

<span class="sd">    output : str</span>
<span class="sd">        Location to save the resulting Target Calibration. It&#39;s a little strange that this is in this function</span>
<span class="sd">        instead of main()</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If true then generate a plot called &quot;overlap.pdf&quot; that shows all the intersections with those used to compute</span>
<span class="sd">        the shifts circled in red.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lst</span>
<span class="sd">        Length N list where N is the number of hdus and the elements are numpy arrays with [x_shift, y_shift]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We&#39;ll call out these two error conditions explicitly because they would both otherwise result in a generic</span>
    <span class="c1">#  IndexError. Here we add some specificity.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intsects</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;The lists of camera positions and intersections do not have the same length!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">refidx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsects</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;The reference position </span><span class="si">{}</span><span class="s1"> cannot be found in the intersection list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">refidx</span><span class="p">))</span>

    <span class="n">hdulist</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)]</span>
    <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_004&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">),</span> <span class="s1">&#39;Number of spatial steps&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsects</span><span class="p">)):</span>
        <span class="n">badshift</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">bdata</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">data</span>
            <span class="n">numx</span><span class="p">,</span> <span class="n">numy</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">bwx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numx</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span>
            <span class="n">bwy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numy</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span>
                      <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">bwx</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">bwx</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">min</span><span class="p">()],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">bdata</span>
            <span class="k">del</span> <span class="n">binary</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">refidx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: skipping reference frame </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff_x</span> <span class="o">=</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">intsects</span><span class="p">[</span><span class="n">refidx</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">diff_y</span> <span class="o">=</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">intsects</span><span class="p">[</span><span class="n">refidx</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">diff_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">diff_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: median distance: </span><span class="si">{:6.4f}</span><span class="s1"> px&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff_r</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: stddev distance: </span><span class="si">{:6.4f}</span><span class="s1"> px&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff_r</span><span class="p">)))</span>

            <span class="c1"># By taking the minimum along each dimension (corresponding to the i&#39;th and ref positions) we are ensuring</span>
            <span class="c1">#  that no points are double counted, which might happen if points are within dmax of two reference points</span>
            <span class="n">min_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff_r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">min_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff_r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">idx_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_ref</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx_ref</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: WARNING: No overlaps found b/t positions </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                                      <span class="n">pos_list</span><span class="p">[</span><span class="n">refidx</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:  THIS IS PROBABLY BAD!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
                <span class="n">badshift</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx_i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

                <span class="n">c_i</span> <span class="o">=</span> <span class="n">intsects</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">idx_i</span><span class="p">]</span>
                <span class="n">c_ref</span> <span class="o">=</span> <span class="n">intsects</span><span class="p">[</span><span class="n">refidx</span><span class="p">][:,</span> <span class="n">idx_ref</span><span class="p">]</span>

                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_i</span> <span class="o">-</span> <span class="n">c_ref</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">c_i</span> <span class="o">-</span> <span class="n">c_ref</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> num intersetions: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> [x, y] shift: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shift</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> [x, y] stdev: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="p">))</span>

        <span class="n">ihdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">()</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CSHIFT1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CSHIFT2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SHTSTD1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SHTSTD2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_005&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BADSHFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">badshift</span><span class="p">,</span> <span class="s1">&#39;If True then the WCS solution is likely wrong!&#39;</span><span class="p">)</span>
        <span class="n">hdulist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ihdu</span><span class="p">)</span>

    <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">target_calibration</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;overlap.pdf&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target_calibration</span></div>


<span class="k">def</span> <span class="nf">gen2</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;Target_Calibration.fits&#39;</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">X_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Y_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">intsects</span><span class="p">:</span>
        <span class="n">X_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">Y_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">X_lst</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">Y_lst</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">startsize</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: starting with </span><span class="si">{}</span><span class="s1"> intersections&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">startsize</span><span class="p">))</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">dR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># After the next three steps all points deemed to be the &#39;same&#39; within the limit of dmax will have their</span>
    <span class="c1"># locations updated to the average of all intersection points.</span>
    <span class="c1">#  In other words, if two HDUs have an point with x locations 10 and 11 then the points new location will be 10.5</span>
    <span class="c1">#  in both frames. In this way the final shifts will be to a global average.</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dR</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">)</span>
    <span class="n">dX</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">dY</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># This step essentially halfs the absolute difference between the coordinates of overlapping points</span>
    <span class="n">dX_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dY_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># And this step brings each pair of overlapping points (there will be exactly 2 per intersection) to the same value.</span>
    <span class="n">X</span> <span class="o">-=</span> <span class="n">dX_avg</span>
    <span class="n">Y</span> <span class="o">-=</span> <span class="n">dY_avg</span>

    <span class="c1"># Find the unique set</span>
    <span class="n">xuidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">yuidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xuidx</span> <span class="o">==</span> <span class="n">yuidx</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xuidx</span><span class="p">,</span> <span class="n">yuidx</span><span class="p">)</span>
        <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;OH SHIT&#39;</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">xuidx</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">yuidx</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: found </span><span class="si">{}</span><span class="s1"> overlapping points&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">startsize</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="n">xshifts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">yshifts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">hdulist</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">()]</span>
    <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_004&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">),</span> <span class="s1">&#39;Number of spatial steps&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">points</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">intsects</span><span class="p">,</span> <span class="n">pos_list</span><span class="p">):</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;binary</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">numx</span><span class="p">,</span> <span class="n">numy</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">bwx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numx</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span>
            <span class="n">bwy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numy</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">,</span>
                      <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">bwx</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">bwx</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">bwy</span><span class="o">.</span><span class="n">min</span><span class="p">()],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">xp</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">yp</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># TODO: There probably shouldn&#39;t be nan&#39;s here at all</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">yp</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">xp</span><span class="p">],</span> <span class="p">[</span><span class="n">yp</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">-</span> <span class="n">X</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">yp</span> <span class="o">-</span> <span class="n">Y</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="n">dy</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="c1"># print(&#39;Skpping&#39;,xp,yp)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">xp</span><span class="p">],</span> <span class="p">[</span><span class="n">yp</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: camera pos </span><span class="si">{}</span><span class="s1"> num overlaps: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: camera pos </span><span class="si">{:}</span><span class="s1"> [x, y] shift: </span><span class="si">{:5.4f}</span><span class="s1">, </span><span class="si">{:5.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ys</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: camera pos </span><span class="si">{:}</span><span class="s1"> [x, y] stdev: </span><span class="si">{:5.4f}</span><span class="s1">, </span><span class="si">{:5.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ys</span><span class="p">)))</span>
        <span class="n">ihdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">()</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_004&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_list</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;VBI_005&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CSHIFT1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CSHIFT2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SHTSTD1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">ihdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SHTSTD2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">hdulist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ihdu</span><span class="p">)</span>

        <span class="n">xshifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
        <span class="n">yshifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

    <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;overlap.pdf&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xshifts</span><span class="p">,</span> <span class="n">yshifts</span>


<div class="viewcode-block" id="make_binary_gauss"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.make_binary_gauss.html#VBI_Pipeline.TargetCalibration.make_binary_gauss">[docs]</a><span class="k">def</span> <span class="nf">make_binary_gauss</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an array to a binary image using a gaussian smoothing method.</span>

<span class="sd">    This method is designed to highlight features with high spatial frequency (i.e., grid lines). The algorithm is:</span>

<span class="sd">     1. Create a smooth version of the input data</span>
<span class="sd">     2. Subtract the smooth and un-smooth data</span>
<span class="sd">     3. Use Otsu&#39;s method to threshold the resulting image</span>
<span class="sd">     4. Apply the threshold to the difference image.</span>

<span class="sd">    The idea here is that the interesting features have been smoothed out of the smooth image and thus the difference</span>
<span class="sd">    image has very strong signal at these features. To work properly the amount of blur should be very close to the</span>
<span class="sd">    pixel width of the features to be extracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        Input data array</span>

<span class="sd">    sigma : float</span>
<span class="sd">        Width (in px units) of smoothing kernel. See above; this should be close to the size of the feature to be</span>
<span class="sd">        extracted.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the thresholding calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True, write out the binary image for later inspection. It will be called &#39;binary.fits&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The binary image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: generating binary image with smoothing kernel </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">sigma</span><span class="p">))</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">gauss</span> <span class="o">-</span> <span class="n">data</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">count_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">binary_threshold</span> <span class="ow">or</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binary_threshold</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Binary threshold fraction (</span><span class="si">{:5.3e}</span><span class="s1">) out of bounds. Refining Otsu to remove outliers&#39;</span><span class="o">.</span> \
              <span class="nb">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">binary_threshold</span> <span class="ow">or</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binary_threshold</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binary_threshold</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">])</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">count_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">:  threshold fraction = </span><span class="si">{:5.3e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">count_high</span> <span class="o">/</span> <span class="n">binary</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: cleaning up low outliers&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">diff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: cleaning up high outliers&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
        <span class="n">diff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigclip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">skif</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;diff.fits&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;binary.fits&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">binary</span></div>


<div class="viewcode-block" id="do_single_frame"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.do_single_frame.html#VBI_Pipeline.TargetCalibration.do_single_frame">[docs]</a><span class="k">def</span> <span class="nf">do_single_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span> <span class="n">theta_window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">rho_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">theta_min_dist</span><span class="o">=</span><span class="mi">1500</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
                    <span class="n">binary_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the equations for all the horizontal and vertical lines in a data array.</span>

<span class="sd">    The lines are found using a Hough Transform and are thus parametrized by (theta, rho). Before the Hough Transform</span>
<span class="sd">    the data are converted to a binary array and the actual transform is done using skimage.</span>

<span class="sd">    The lines discovered by the transform are constrained to be within +/- 20 degrees of horizontal or vertical.</span>
<span class="sd">    Finally, any lines with angles that significantly deviate from the group average are removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        Input data array. Should be 2-d</span>

<span class="sd">    gauss_sigma : float</span>
<span class="sd">        Width of smoothing kernel used to construct a binary image from the input data. Should be slightly less than</span>
<span class="sd">        the pixel width of the grid lines.</span>

<span class="sd">    theta_window : float</span>
<span class="sd">        Window in radians around (before and after) each peak angle within which to search for peaks in rho.</span>

<span class="sd">    rho_window : float</span>
<span class="sd">        Window in pixels around (before and after) each peak rho value within which to refine location of peak angle.</span>

<span class="sd">    theta_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in theta.</span>

<span class="sd">    rho_min_dist : float</span>
<span class="sd">        Minimum distance (in Hough space coordinates) allowed between peaks in rho. This parameter is highly dependent</span>
<span class="sd">        on the pixel scale of the grid lines.</span>

<span class="sd">    rho_smooth : float</span>
<span class="sd">        Sigma of smoothing kernel used to remove noise from the rho rss. Something b/t 5 and 10 is probably good.</span>

<span class="sd">    binary_threshold : float</span>
<span class="sd">        Min percentage of pixels to be on one side of the Otsu threshold when constructing the binary image.</span>
<span class="sd">        If the percentage of pixels above the threshold is outside the range (binary_threshold, 1 - binary_threshold),</span>
<span class="sd">        then some cleaning of outlying pixels is performed.</span>

<span class="sd">    sigclip : float</span>
<span class="sd">        Any pixels beyond sigclip standard deviations from the mean are excluded from the binary thresholding</span>
<span class="sd">        calculation.</span>

<span class="sd">    debug : bool</span>
<span class="sd">        If True the code will stop at each hdu (i.e., exposure) and generate some diagnostic plots that show the</span>
<span class="sd">        computed lines and grid intersections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        (rho, theta) where each element is an ndarray with the associated values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="s1">&#39;data.fits&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="n">make_binary_gauss</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">binary_threshold</span><span class="o">=</span><span class="n">binary_threshold</span><span class="p">,</span> <span class="n">sigclip</span><span class="o">=</span><span class="n">sigclip</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: performing Hough transform&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">()))</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">skit</span><span class="o">.</span><span class="n">hough_line</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1500</span><span class="p">))</span>
    <span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">theta_min_dist</span><span class="p">)</span>
    <span class="n">peak_theta</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: found peaks in theta RSS at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">idx</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: most prominent angles: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">peak_theta</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: difference: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">peak_theta</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rss</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">theta</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">peak_theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;trss.pdf&#39;</span><span class="p">)</span>

    <span class="n">grid_theta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">grid_rho</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peak_theta</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:}</span><span class="s2">: finding rho&#39;s for angle </span><span class="si">{:5.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">(),</span> <span class="n">t</span><span class="p">))</span>
        <span class="n">tidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">theta_window</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rrss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="n">tidx</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">srrss</span> <span class="o">=</span> <span class="n">spnd</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">rrss</span><span class="p">,</span> <span class="n">rho_smooth</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span><span class="n">srrss</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">rho_min_dist</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">peak_rho</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">srrss</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rangeid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rrss</span> <span class="o">&gt;</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rrss</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="n">rangeid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">rho</span><span class="p">[</span><span class="n">rangeid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">srrss</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rrss</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">rho</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">peak_rho</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>

            <span class="n">ridx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rho</span> <span class="o">-</span> <span class="n">peak_rho</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">rho_window</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">trss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">ridx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">ridx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">tidx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">tridx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">trss</span><span class="p">)]</span>
            <span class="n">final_theta</span> <span class="o">=</span> <span class="n">pku</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">tidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">tidx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">trss</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">tridx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">grid_rho</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak_rho</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">grid_theta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_theta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;rrss.pdf&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">grid_theta</span><span class="p">,</span> <span class="n">grid_rho</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">pidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pidx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">pidx</span><span class="p">],</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;im.pdf&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_rho</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_intersections"><a class="viewcode-back" href="../../api/VBI_Pipeline.TargetCalibration.find_intersections.html#VBI_Pipeline.TargetCalibration.find_intersections">[docs]</a><span class="k">def</span> <span class="nf">find_intersections</span><span class="p">(</span><span class="n">sklines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a list of intersection between horizontal and vertical input lines.</span>

<span class="sd">    Lines are pre-screened so that intersections near infinity within vertical and horizontal line sets are ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sklines : tuple</span>
<span class="sd">        An (theta, rho) tuple where each element is a numpy.ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Shape (2,N) corresponding to (x,y) coordinates for each of the N intersections</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inter_lst</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">sklines</span>
    <span class="n">hidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">theta</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">vidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">theta</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ht</span><span class="p">,</span> <span class="n">hr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="n">rho</span><span class="p">[</span><span class="n">hidx</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">vt</span><span class="p">,</span> <span class="n">vr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">vidx</span><span class="p">],</span> <span class="n">rho</span><span class="p">[</span><span class="n">vidx</span><span class="p">]):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">vr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span> <span class="o">-</span> <span class="n">hr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">vt</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ht</span> <span class="o">-</span> <span class="n">vt</span><span class="p">)</span>
            <span class="n">hy</span> <span class="o">=</span> <span class="p">(</span><span class="n">hr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span> <span class="o">-</span> <span class="n">vr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ht</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ht</span> <span class="o">-</span> <span class="n">vt</span><span class="p">)</span>

            <span class="n">inter_lst</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">hy</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">inter_lst</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>


<span class="k">def</span> <span class="nf">plot_intersections</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">imagefile</span><span class="o">=</span><span class="s1">&#39;binary.fits&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a debug plot that shows all of the found intersections on top of the input image.</span>

<span class="sd">    Actually, it&#39;s the binary version of the input image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intersections : numpy.ndarray</span>
<span class="sd">        Shape (2,N), the x,y coordinates of intersections</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The resulting plot is written to &#39;intersections.pdf&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">imagefile</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intersections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;intersections.pdf&#39;</span><span class="p">)</span>

    <span class="k">return</span>


<span class="k">def</span> <span class="nf">intersections_to_ds9</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Quick script to generate a ds9 region file from a list of line intersections&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Region file format: DS9 version 4.1</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s1">&#39;global color=red dashlist=8 3 width=4 font=&quot;helvetica 10 normal roman&quot; select=1 highlite=1 dash=0 &#39;</span>
                <span class="s1">&#39;fixed=0 edit=1 move=1 delete=1 include=1 source=1</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;physical</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intersections</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;circle(</span><span class="si">{:8.5f}</span><span class="s1">,</span><span class="si">{:8.5f}</span><span class="s1">,20)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intersections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">compare_gens</span><span class="p">(</span><span class="n">rdx_dir</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">refidx</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">VBI_Pipeline</span> <span class="k">import</span> <span class="n">ScienceCalibration</span><span class="p">,</span> <span class="n">ApplyTargetCalibration</span>

    <span class="n">pGD1</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/linegrid_proc.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rdx_dir</span><span class="p">))</span>
    <span class="n">pGD2</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/linegrid_proc.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rdx_dir</span><span class="p">))</span>

    <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">collect_intersections</span><span class="p">(</span><span class="n">pGD1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">gauss_sigma</span><span class="o">=</span><span class="n">gauss_sigma</span><span class="p">,</span> <span class="n">rho_min_dist</span><span class="o">=</span><span class="n">rho_min_dist</span><span class="p">)</span>

    <span class="n">generate_target_calibration</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;TC1.fits&#39;</span><span class="p">,</span> <span class="n">refidx</span><span class="o">=</span><span class="n">refidx</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>
    <span class="n">gen2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;TC2.fits&#39;</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="n">dmax</span><span class="p">)</span>

    <span class="n">TC1</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;TC1.fits&#39;</span><span class="p">)</span>
    <span class="n">TC2</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">FitsData</span><span class="p">(</span><span class="s1">&#39;TC2.fits&#39;</span><span class="p">)</span>

    <span class="n">ScienceCalibration</span><span class="o">.</span><span class="n">generate_science_data</span><span class="p">(</span><span class="n">pGD1</span><span class="p">,</span> <span class="n">TC1</span><span class="p">)</span>
    <span class="n">ScienceCalibration</span><span class="o">.</span><span class="n">generate_science_data</span><span class="p">(</span><span class="n">pGD2</span><span class="p">,</span> <span class="n">TC2</span><span class="p">)</span>

    <span class="n">ApplyTargetCalibration</span><span class="o">.</span><span class="n">stitch_FitsData</span><span class="p">(</span><span class="n">pGD1</span><span class="p">)</span><span class="o">.</span><span class="n">write_out</span><span class="p">(</span><span class="s1">&#39;spGD1.fits&#39;</span><span class="p">)</span>
    <span class="n">ApplyTargetCalibration</span><span class="o">.</span><span class="n">stitch_FitsData</span><span class="p">(</span><span class="n">pGD2</span><span class="p">)</span><span class="o">.</span><span class="n">write_out</span><span class="p">(</span><span class="s1">&#39;spGD2.fits&#39;</span><span class="p">)</span>

    <span class="k">return</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <div class="left-footer">
         &copy; 2018, Arthur Eigenbrot
       <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
    </div>
   
    <div class="right-footer">
      Last updated on 07 Jun 2018.
    </div>
    <div class="centre-footer">
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4
    </div>
  </div>
</footer>
  </body>
</html>